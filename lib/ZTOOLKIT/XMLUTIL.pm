package ZTOOLKIT::XMLUTIL;

use Carp;

##
## goes through a variable length mix of arrays and hashrefs to determine if any keys have
##		{urn:ebay:apis:eBLBaseComponents} namespace (generated by xml::sax::simple)
##		and removes them by copying the keys.
sub stripNamespace {
	my ($ref) = @_;

	if (ref($ref) eq 'HASH') {
		foreach my $k (keys %{$ref}) {
			if (ref($ref->{$k}) ne '') { stripNamespace($ref->{$k}); }
			if ($k =~ /^\{(urn|http)\:.*?\}(.*?)$/) {
				$ref->{$2} = $ref->{$k};
				delete $ref->{$k};
				}
			}
		}
	elsif (ref($ref) eq 'ARRAY') {
		foreach my $x (@{$ref}) {
			&stripNamespace($x);
			}
		}
	}


##
## flattens a simple XML ForceArray=>1 into a hash
##		this is not safe for any element which has nested data structures.
##
sub SXMLflatten {
	my ($ref, %options) = @_;
	
	my $out = $options{'out'};
	my $path = $options{'path'};
	if (not defined $out) {
		$out = {};
		$path = '';
		}
	
	# use Data::Dumper; print Dumper($out,$path,$ref);
	
	my %out = ();
	foreach my $k (keys %{$ref}) {
		# print "$path.$k\n";
		
		if (ref($ref->{$k}) eq 'ARRAY') {
			my $i = 0;
			foreach my $aref (@{$ref->{$k}}) {
				$k =~ s/\{.*?\}//g;		# strip namespaces e.g. {http://fedex.com/ws/rate/v7}
				if (ref($aref) eq 'HASH') {
					ZTOOLKIT::XMLUTIL::SXMLflatten($aref,path=>"$path.$k",out=>$out);
					$i++;
					}
				else {
					$out->{"$path.$k"} = $aref;
					}
				}
			}
		elsif (ref($ref->{$k}) eq 'HASH') {
			## this is an attribute.		
			my $tmp = "$path..$k";
			$tmp =~ s/\{.*?\}//g;	# strip namespaces e.g. {http://fedex.com/ws/rate/v7}
			$out->{$tmp} = $ref->{$k};
			# Carp::confess("can't support hash");
			}
		else {
			## scalar!
			my $tmp = "$path.$k";
			$tmp =~ s/\{.*?\}//g;   # strip namespaces e.g. {http://fedex.com/ws/rate/v7}
			$out->{ $tmp } = $ref->{$k};
			}
		}
		
	return($out);
	}



1;